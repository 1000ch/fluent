<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title></title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet">
  <link href="../../assets/css/vendor/font-awesome-ie7.css" rel="stylesheet">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet">
  <link href="../../assets/css/plato.css" rel="stylesheet">
  <link href="../../assets/css/plato-file.css" rel="stylesheet">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="http://github.com/jsoverson/plato">Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"></i></a></h2>
      <p class="stat">69.25</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC"></i></h2>
      <p class="stat">1074</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty"></i></a></h2>
      <p class="stat">125.15</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs"></i></a></h2>
      <p class="stat">8.92</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">/**
 * fluent.js
 *
 * Copyright 1000ch&lt;http://1000ch.net/&gt;
 * licensed under the MIT license.
 **/
(function(window, undefined) {
  &quot;use strict&quot;;
  var win = window,
      doc = window.document,
      docElem = doc.documentElement,
      loc = window.location;

  //cache empty structure
  var emptyArray = [],
      emptyObject = {},
      emptyElement = doc.createElement(&quot;div&quot;);

  //cache reference
  var toString = emptyObject.toString,
      arrayForEach = emptyArray.forEach,
      arrayMap = emptyArray.map,
      arraySlice = emptyArray.slice,
      arraySplice = emptyArray.splice,
      arrayIndexOf = emptyArray.indexOf,
      arrayLastIndexOf = emptyArray.lastIndexOf;

  //string polyfills
  if(!String.prototype.repeat) {
    String.prototype.repeat = function(count) {
      if((count |= 0 ) &lt;= 0) {
        throw new RangeError();
      }
      var result = &#039;&#039;, self = this;
      while(count) {
        if(count &amp; 1) {
          result += self;
        }
        if(count &gt;= 1) {
          self += self;
        }
      }
      return result;
    };
  }
  if(!String.prototype.startsWith) {
    String.prototype.startsWith = function(value, position) {
      return (this.indexOf(value, position |= 0) === position);
    };
  }
  if(!String.prototype.endsWith) {
    String.prototype.endsWith = function(value, position) {
      return (this.lastIndexOf(value, position) === (position &gt;= 0 ? position | 0 : this.length - 1));
    };
  }
  if(!String.prototype.contains) {
    String.prototype.contains = function(value, index) {
      return (this.indexOf(value, index | 0) !== -1);
    };
  }
  if(!String.prototype.toArray) {
    String.prototype.toArray = function(value) {
      return this.split(&quot;&quot;);
    };
  }

  var rxConciseSelector = /^(?:#([\w\-]+)|(\w+)|\.([\w\-]+))$/,//filter #id, tagName, .className
      rxIdSelector = /^#([\w\-]+)$/,
      rxClassSelector = /^\.([\w\-]+)$/,
      rxTagSelector = /^[\w\-]+$/,
      rxReady = /complete|loaded|interactive/;

  var matches = docElem.matchesSelector ||
      docElem.webkitMatchesSelector ||
      docElem.mozMatchesSelector ||
      docElem.msMatchesSelector ||
      docElem.oMatchesSelector;


  /**
   * base class
   * @param {String} obj
   * @param {String|HTMLElement}
   */
  function Fluent(selector) {
    return new Fluent.fn.initialize(selector);
  }

  /**
   * base prototype
   */
  Fluent.fn = Fluent.prototype = {
    constructor: Fluent,
    length: 0,
    /**
     * Fluent initializer
     * @param {String} selector
     * @returns {Fluent}
     */
    initialize: function(selector) {
      var elementList = [];
      if(!selector) {
        return this;
      } else if(isString(selector)) {
        //if selector is string
        elementList = __qsaHook(selector);
      } else if(selector.nodeType) {
        //if selector is single dom element
        elementList.push(selector);
      } else if(__isLikeArray(selector)) {
        //if selector is array,
        //select only dom element
        elementList = arrayFilter.call(selector, function(item) {
          return !!item.nodeType;
        });
      }
      var len = this.length = elementList.length;
      while(len--) {
        this[len] = elementList[len];
      }
      return this;
    },
    /**
     * execute function to all element
     * @param {Function} callback
     * @return {Fluent}
     */
    each: function(callback) {
      var args = arraySlice.call(arguments, 1);
      for(var i = 0, len = this.length;i &lt; len;i++) {
        callback(this[i], i);
      }
      return this;
    }
  };

  Fluent.fn.initialize.prototype = Fluent.fn;

  /**
   * value is typeof key, or not.
   * @param {String} key
   * @param {Object} value
   * @return {Boolean}
   */
  function __is(key, value) {
    return (toString.call(value) === &quot;[object &quot; + key + &quot;]&quot;);
  }

  /**
   * value is string or not
   * @param {Object} value
   * @return {Boolean}
   */
  function isString(value) {
    return __is(&quot;String&quot;, value);
  }

  /**
   * value is function or not
   * @param {Object} value
   * @return {Boolean}
   */
  Fluent.isFunction = function(value) {
    return __is(&quot;Function&quot;, value);
  };

  /**
   * value is nodeList or not
   * @param {Object} value
   * @return {Boolean}
   */
  function __isNodeList(value) {
    return __is(&quot;NodeList&quot;, value);
  }
  /**
   * value is like an array or not
   * @param {Object} value
   * @return {Boolean}
   */
  function __isLikeArray(value) {
    return (typeof value.length == &quot;number&quot;);
  }
  /**
   * is appendable node or not
   * @param {HTMLElement} element
   * @return {Boolean}
   */
  function __isAppendable(element) {
    if(element.nodeType) {
      var nodeType = element.nodeType;
      if(nodeType === 1 || nodeType === 11 || nodeType === 9) {
        return !!element.appendChild;
      }
    }
    return false;
  }
  /**
   * get computed style of element
   * @param {HTMLElement} element
   * @param {String} key
   * @return {String}
   */
  function __computedStyle(element, key) {
    if(element.currentStyle) {
      return element.currentStyle[key];
    } else if(win.getComputedStyle) {
      return win.getComputedStyle(element, null).getPropertyValue(key);
    }
    return null;
  }
  /**
   * create element with attributes
   * @param {String} tagName
   * @param {Object} attributes
   */
  function __createElement(tagName, attributes) {
    var element = doc.createElement(tagName);
    if(attributes) {
      for(var key in attributes) {
        element.setAttribute(key, attributes[key]);
      }
    }
    return element;
  }
  /*
   * extend and hook querySelectorAll
   * evaluate selector concisely
   * if selector is &quot;#id&quot;, call getElementById
   * if selector is &quot;.className&quot;, call getElementsByClassName
   * if selector is &quot;tagName&quot;, call getElementsByTagName

   * if context is given, search element with selector
   * in context (or related condition).
   * @param {String} selector css selector
   * @param {HTMLElement} context
   * @return {Array}
   */
  function __qsaHook(selector, context) {
    context = context ? context : doc;

    var m = rxConciseSelector.exec(selector);

    if(m) {//regex result is not undefined
      if(m[1]) {//if selector is &quot;#id&quot;
        return [doc.getElementById(m[1])];
      } else if(m[2]) {//if selector is &quot;tagName&quot;
        return context.getElementsByTagName(m[2]);
      } else if(m[3]) {//if selector is &quot;.className&quot;
        return context.getElementsByClassName(m[3]);
      }
    }

    //process for case of &quot;#id [any selector]&quot;
    var tokenIndex = -1, tokenList = selector.split(&quot; &quot;);
    tokenList.some(function(token, index, array) {
      if(rxIdSelector.test(token)) {
        tokenIndex = index;
        return true;
      }
    });
    if(tokenIndex !== -1) {
      var idSelector = tokenList[tokenIndex];
      if(tokenIndex == tokenList.length - 1) {
        return [doc.querySelector(idSelector)];
      } else {
        return __qsaHook(tokenList.slice(tokenIndex + 1).join(&quot; &quot;), doc.querySelector(idSelector));
      }
    }

    return context.querySelectorAll(selector);
  }
  /**
   * create callback closure
   * @param {HTMLElement} parentNode
   * @param {String} selector
   * @param {Function} callback
   */
  function __createDelegateClosure(parentNode, selector, callback) {
    var closure = function(e) {
      var parent = parentNode;
      var children = __qsaHook(selector, parent);
      arrayForEach.call(children, function(child) {
        if(child.compareDocumentPosition(e.target) === 0) {
          callback.call(child, e);
        }
      });
    };
    return closure;
  }
  /**
   * normalize object to node array.
   * @param {Fluent|NodeList|Array} value
   */
  function __normalizeNode(value) {
    var nodeList = [];
    if(value.nodeType) {
      nodeList.push(value);
    } else if(value instanceof Fluent) {
      nodeList = value.toArray();
    } else if(__isNodeList(value)) {
      nodeList = value;
    } else if(__isLikeArray(value)) {
      for(var i = 0, len = value.length;i &lt; len;i++) {
        if(value[i].nodeType) {
          nodeList[nodeList.length] = value[i];
        }
      }
    }
    return nodeList;
  }
  /**
   * generic each function
   * @description if callback function returns false, break loop.
   * @param {Object} target
   * @param {Function} callback
   * @return {Object}
   */
  Fluent.each = function(target, callback) {
    var args = arraySlice.call(arguments, 2);
    var i, len = target.length, key, result;
    if(args.length !== 0) {
      //if args is not &quot;false&quot;
      if(__isLikeArray(target)) {
        for(i = 0;i &lt; len;i++) {
          result = callback.apply(target[i], args);
          if(result === false) {
            break;
          }
        }
      } else {
        for(key in target) {
          result = callback.apply(target[key], args);
          if(result === false) {
            break;
          }
        }
      }
    } else {
      //if args is null, undefined, 0, &quot;&quot;
      if(__isLikeArray(target)) {
        for(i = 0;i &lt; len;i++) {
          result = callback.call(target[i], target[i], i);
          if(result === false) {
            break;
          }
        }
      } else {
        for(key in target) {
          result = callback.call(target[key], target[key], i);
          if(result === false) {
            break;
          }
        }
      }
    }
    return target;
  };
  /**
   * extend object hardly
   * @description if same property exist, it will be overriden
   * @param {Object} target
   * @param {Object} src
   * @return {Object}
   */
  Fluent.extend = function(target, src) {
    var key, keys = Object.keys(src);
    for(var i = 0, len = keys.length;i &lt; len;i++) {
      key = keys[i];
      //even if &quot;key&quot; property already exist, set into &quot;key&quot;
      if(src.hasOwnProperty(key)) {
        target[key] = src[key];
      }
    }
    return target;
  };
  /**
   * extend object softly
   * @description if same property exist, it will not be overriden
   * @param {Object} target
   * @param {Object} src
   * @return {Object}
   */
  Fluent.fill = function(target, src) {
    var key, keys = Object.keys(src);
    for(var i = 0, len = keys.length;i &lt; len;i++) {
      key = keys[i];
      //if &quot;key&quot; is not undefined, &quot;key&quot; will not be rewrite
      if(src.hasOwnProperty(key) &amp;&amp; !(key in target)) {
        target[key] = src[key];
      }
    }
    return target;
  };
  /**
   * merge array or object (like an array) into array
   * @param {Array} srcList
   * @param {Array|* which has length property}
   */
  Fluent.merge = function(srcList, mergeList) {
    arrayForEach.call(mergeList, function(mergeElement) {
      if(arrayIndexOf.call(srcList, mergeElement) &lt; 0) {
        srcList[srcList.length] = mergeElement;
      }
    });
  };
  /**
   * execute callback when dom content loaded
   * @param {Function} callback
   */
  Fluent.ready = function(callback) {
    var args = arraySlice.call(arguments, 1);
    if (rxReady.test(doc.readyState)) {
      if(!args) {
        callback.call(doc);
      } else {
        callback.apply(doc, args);
      }
    } else {
      doc.addEventListener(&quot;DOMContentLoaded&quot;, function() {
        if(!args) {
          callback.call(doc);
        } else {
          callback.apply(doc, args);
        }
      }, false);
    }
  };
  /**
   *
   * @param {Array} array
   * @param {String} key
   * @return {Array}
   */
  Fluent.pluck = function(array, key) {
    return arrayMap.call(array, function(value) {
      return value[key];
    });
  };
  /**
   * copy object
   * @param {Object} target
   * @return {Object}
   */
  Fluent.copy = function(target) {
    var buffer = Object.create(Object.getPropertyOf(target));
    var propertyNames = Object.getOwnPropertyNames(target);

    arrayForEach.call(propertyNames, function(name) {
      Object.defineProperty(buffer, name, Object.getOwnPropertyDescriptor(target, name));
    });
    return buffer;
  };
  /**
   * define function
   * @param {Object} properties
   * @param {Function} superClass
   * @returns {Function}
   */
  Fluent.defineClass = function(properties, superClass) {
    var Constructor = properties.hasOwnProperty(&quot;constructor&quot;) ? properties.constructor : function() {};
    var Class = function() {};
    if(superClass) {
      Class.prototype = Object.create(superClass.prototype);
    } else {
      Class.constructor = Constructor;
    }
    Fluent.extend(Class.prototype, properties);
    return Class;
  };
  /**
   * bind
   * @param {HTMLElement} targetNode
   * @param {String} type
   * @param {Function} callback
   * @param {Boolean} useCapture
   */
  Fluent.bind = function(targetNode, type, callback, useCapture) {
    if(targetNode &amp;&amp; targetNode.addEventListener) {
      targetNode.addEventListener(type, callback, useCapture);
    }
  };
  /**
   * unbind
   * @param {HTMLElement} targetNode
   * @param {String} type
   * @param {Function} callback
   * @param {Boolean} useCapture
   */
  Fluent.unbind = function(targetNode, type, callback, useCapture) {
    if(targetNode &amp;&amp; targetNode.removeEventListener) {
      targetNode.removeEventListener(type, callback, useCapture);
    }
  };
  /**
   * once
   * @param {HTMLElement} targetNode
   * @param {String} type
   * @param {Function} callback
   * @param {Boolean} useCapture
   */
  Fluent.once = function(targetNode, type, callback, useCapture) {
    var wrapOnce = function(e) {
      callback.call(targetNode, e);
      targetNode.removeEventListener(type, wrapOnce, useCapture);
    };
    targetNode.addEventListener(type, wrapOnce, useCapture);
  };
  /**
   * delegate
   * @param {HTMLElement} targetNode
   * @param {String} type
   * @param {String} selector
   * @param {Function} callback
   */
  Fluent.delegate = function(targetNode, type, selector, callback) {
    if(!targetNode.eventStore) {
      targetNode.eventStore = {};
    }
    if(!targetNode.eventStore.hasOwnProperty(type)) {
      targetNode.eventStore[type] = [];
    }
    var closure = __createDelegateClosure(targetNode, selector, callback);
    var closures = Fluent.pluck(targetNode.eventStore[type], &quot;closure&quot;);
    if(closures.indexOf(closure) === -1) {
      targetNode.eventStore[type].push({
        &quot;selector&quot;: selector,
        &quot;callback&quot;: callback,
        &quot;closure&quot;: closure
      });
    }
    targetNode.addEventListener(type, closure);
  };
  /**
   * undelegate
   * @param {HTMLElement} targetNode
   * @param {String*} type
   * @param {String*} selector
   * @param {Function*} callback
   */
  Fluent.undelegate = function(targetNode, type, selector, callback) {
    var storedData, callbacks, selectors, index;
    if(targetNode.eventStore) {
      if(type &amp;&amp; selector &amp;&amp; callback) {
        storedData = targetNode.eventStore[type];
        callbacks = Fluent.pluck(storedData, &quot;callback&quot;);
        index = callbacks.indexOf(callback);
        if(index &gt; -1) {
          targetNode.removeEventListener(type, storedData[index].closure);
          targetNode.eventStore[type].splice(index, 1);
        }
      } else if(type &amp;&amp; selector &amp;&amp; !callback) {
        storedData = targetNode.eventStore[type];
        selectors = Fluent.pluck(storedData, &quot;selector&quot;);
        index = selectors.indexOf(selector);
        if(index &gt; -1) {
          targetNode.removeEventListener(type, storedData[index].closure);
          targetNode.eventStore[type].splice(index, 1);
        }
      } else if(type &amp;&amp; !selector &amp;&amp; !callback) {
        storedData = targetNode.eventStore[type];
        arrayForEach.call(storedData, function(item) {
          targetNode.removeEventListener(type, item.closure);
        });
        delete targetNode.eventStore[type];
      } else {
        Object.keys(targetNode.eventStore).forEach(function(key) {
          storedData = targetNode.eventStore[key];
          arrayForEach.call(storedData, function(item) {
            targetNode.removeEventListener(key, item.closure);
          });
          delete targetNode.eventStore[key];
        });
      }
    }
  };


  /**
   * add class to element
   * @param {HTMLElement} targetNode
   * @param {String} value
   */
  Fluent.addClass = function(targetNode, value) {
    var classList = (value + &quot;&quot;).split(&quot; &quot;);
    var oldClass = targetNode.className + &quot;&quot;;
    var arrayBuffer = oldClass.split(&quot; &quot;);
    var valueIndex = -1;
    for(var i = 0, len = classList.length;i &lt; len;i++) {
      valueIndex = arrayBuffer.indexOf(classList[i]);
      if(valueIndex === -1) {
        arrayBuffer.push(classList[i]);
      }
    }
    var newClass = arrayBuffer.join(&quot; &quot;);
    if(newClass != oldClass) {
      //if className is updated
      targetNode.className = newClass;
    }
  };
  /**
   * remove class from element
   * @param {HTMLElement} targetNode
   * @param {String} value
   */
  Fluent.removeClass = function(targetNode, value) {
    var classList = (value + &quot;&quot;).split(&quot; &quot;);
    var oldClass = targetNode.className + &quot;&quot;;
    var arrayBuffer = oldClass.split(&quot; &quot;);
    var valueIndex = -1;
    for(var i = 0, len = classList.length;i &lt; len;i++) {
      valueIndex = arrayBuffer.indexOf(classList[i]);
      if(valueIndex !== -1) {
        arrayBuffer.splice(valueIndex, 1);
      }
    }
    var newClass = arrayBuffer.join(&quot; &quot;);
    if(newClass != oldClass) {
      //if className is updated
      targetNode.className = newClass;
    }
  };
  /**
   * toggle class of element
   * @param {HTMLElement} targetNode
   * @param {String} value
   */
  Fluent.toggleClass = function(targetNode, value) {
    var classList = (value + &quot;&quot;).split(&quot; &quot;);
    var oldClass = targetNode.className + &quot;&quot;;
    var arrayBuffer = oldClass.split(&quot; &quot;);
    var valueIndex = -1;
    for(var i = 0, len = classList.length;i &lt; len;i++) {
      valueIndex = arrayBuffer.indexOf(classList[i]);
      if(valueIndex === -1) {
        //if does not exist
        arrayBuffer.push(value);
      } else {
        //if exist
        arrayBuffer.splice(valueIndex, 1);
      }
    }
    var newClass = arrayBuffer.join(&quot; &quot;);
    if(newClass != oldClass) {
      //if className is updated
      targetNode.className = newClass;
    }
  };
  /**
   * target has class or not.
   * @param {HTMLElement} targetNode
   * @param {String} value
   */
  Fluent.hasClass = function(targetNode, value) {
    var arrayBuffer = targetNode.className.split(&quot; &quot;);
    return (arrayBuffer.indexOf(value + &quot;&quot;) != -1);
  };
  /**
   * serialize object to query string
   * @param {Object} data
   * @return {String}
   */
  Fluent.serialize = function(data) {
    var ret = [], key, value;
    for(key in data) {
      if(data.hasOwnProperty(key)) {
        ret.push(encodeURIComponent(key) + &quot;=&quot; + encodeURIComponent(value));
      }
    }
    return ret.join(&quot;&amp;&quot;).replace(&quot;%20&quot;, &quot;+&quot;);
  };
  /**
   * deserialize from query string
   * @param {String} data
   * @return {Object}
   */
  Fluent.deserialize = function(data) {
    var ret = {}, query = &quot;&quot;;
    if(data) {
      query = data;
    } else {
      var href = loc.href, index = href.indexOf(&quot;?&quot;);
      query = href.substring(index + 1);
    }
    if(query.charAt(0) == &quot;?&quot;) {
      query = query.substring(1);
    }
    var array = query.split(&quot;&amp;&quot;), buffer = [];
    for(var i = 0, len = array.length;i &lt; len;i++) {
      buffer = array[i].split(&quot;=&quot;);
      if(buffer.length == 2) {
        ret[decodeURIComponent(buffer[0])] = decodeURIComponent(buffer[1]);
      }
    }
    return ret;
  };
  /**
   * string format
   * @param {String} str
   * @param {Object} replacement
   * @return {String}
   */
  Fluent.format = function(str, replacement) {
    if (typeof replacement != &quot;object&quot;) {
      replacement = arraySlice.call(arguments);
    }
    return str.replace(/\{(.+?)\}/g, function(m, c) {
      return (replacement[c] !== null) ? replacement[c] : m;
    });
  };
  /**
   * camelize
   * @param {String} str
   * @return {String}
   */
  Fluent.camelize = function(str) {
    return str.replace(/-+(.)?/g, function(match, character){
      return character ? character.toUpperCase() : &quot;&quot;;
    });
  };
  /**
   * dasherize
   * @param {String} str
   * @return {String}
   */
  Fluent.dasherize = function(str) {
    return str.replace(/::/g, &#039;/&#039;)
      .replace(/([A-Z]+)([A-Z][a-z])/g, &#039;$1_$2&#039;)
      .replace(/([a-z\d])([A-Z])/g, &#039;$1_$2&#039;)
      .replace(/_/g, &#039;-&#039;)
      .toLowerCase();
  };
  /**
   * load script immediately or asynchronously
   * @param {String} path
   * @param {Function} callback
   * @param {String} async
   * @param {String} defer
   */
  Fluent.loadScript = function(path, callback, async, defer) {
    var script = __createElement(&quot;script&quot;, {
      src: path,
      charset: &quot;utf-8&quot;,
      type: &quot;text/javascript&quot;,
      async: (async === undefined ? false : async),
      defer: (defer === undefined ? false : defer)
    });
    script.onload = script.onreadystatechange = function() {
      script.onload = script.onreadystatechange = null;
      if(callback) {
        callback();
      }
    };
    doc.querySelector(&quot;head&quot;).appendChild(script);
  };
  /**
   * escape html string
   * @param {String} value
   * @return {String}
   */
  Fluent.escapeHTML = function(value) {
    value = value + &quot;&quot;;
    var escapeMap = {
      &quot;&amp;&quot;: &quot;&amp;amp;&quot;,
      &#039;&quot;&#039;: &quot;&amp;quot;&quot;,
      &quot;&lt;&quot;: &quot;&amp;lt;&quot;,
      &quot;&gt;&quot;: &quot;&amp;gt;&quot;
    };
    return value.replace(/(&amp;|&quot;|&lt;|&gt;)/g, function(c) {
      return escapeMap[c];
    });
  };
  /**
   * unescape html string
   * @param {String} value
   * @return {String}
   */
  Fluent.unescapeHTML = function(value) {
    value = value + &quot;&quot;;
    var unescapeMap = {
      &quot;&amp;amp;&quot;: &quot;&amp;&quot;,
      &quot;&amp;quot;&quot;: &#039;&quot;&#039;,
      &quot;&amp;lt;&quot;: &quot;&lt;&quot;,
      &quot;&amp;gt;&quot;: &quot;&gt;&quot;
    };
    return value.replace(/(&amp;amp;|&amp;quot;|&amp;lt;|&amp;gt;)/g, function(c) {
      return unescapeMap[c];
    });
  };

  var _FluentEvent = {
    /**
     * bind event
     * @param {String} type
     * @param {Function} eventHandler
     * @param {Boolean} useCapture
     * @return {Fluent}
     */
    bind: function(type, eventHandler, useCapture) {
      return this.each(function(element, index) {
        element.addEventListener(type, eventHandler, useCapture);
      });
      return this;
    },
    /**
     * unbind event
     * @param {String} type
     * @param {Function} eventHandler
     * @param {Boolean} useCapture
     * @return {Fluent}
     */
    unbind: function(type, eventHandler, useCapture) {
      return this.each(function(element, index) {
        element.removeEventListener(type, eventHandler, useCapture);
      });
    },
    /**
     * dispatch event
     * @param {String} type
     * @returns {Fluent}
     */
    trigger: function(type) {
      return this.each(function(element, index) {
        var event = doc.createEvent(&quot;Event&quot;);
        event.initEvent(type, true, false);
        element.dispatchEvent(event);
      });
    },
    /**
     * bind event once
     * @param {String} type
     * @param {Function} eventHandler
     * @param {Boolean} useCapture
     * @return {Fluent}
     */
    once: function(type, eventHandler, useCapture) {
      this.each(function(element, index) {
        Fluent.once(element, type, eventHandler, useCapture);
      });
      return this;
    },
    /**
     * begin propagation event
     * @param {String} type
     * @param {Function} eventHandler
     * @return {Fluent}
     */
    delegate: function(type, selector, eventHandler) {
      return this.each(function(element, index) {
        Fluent.delegate(element, type, selector, eventHandler);
      });
    },
    /**
     * finish propagation event
     * @param {String} type
     * @param {Function} eventHandler
     * @return {Fluent}
     */
    undelegate: function(type, selector, eventHandler) {
      return this.each(function(element, index) {
        Fluent.undelegate(element, type, selector, eventHandler);
      });
    }
  };

  var _FluentTraversing = {
    /**
     * get elements by search with callback
     * @param {Function} callback
     * @return {Fluent}
     */
    filter: function(callback) {
      return new Fluent(arrayFilter.call(this, callback));
    },
    /**
     * apply callback and get elements
     * @param {Function} callback
     * @return {Fluent}
     */
    map: function(callback) {
      var array = [], element;
      for(var i = 0, len = this.length;i &lt; len;i++) {
        element = callback(this[i], i);
        if(element !== null) {
          array.push(element);
        }
      }
      return new Fluent(array);
    },
    /**
     * find elements which matches selector
     * @param {String} selector
     * @return {Fluent}
     */
    find: function(selector) {
      var array = [];
      for(var i = 0, len = this.length;i &lt; len;i++) {
        if(matches.call(this[i], selector)) {
          Fluent.merge(array, this[i]);
        }
      }
      return new Fluent(array);
    }
  };

  var _FluentManipulation = {
    /**
     * set innerHTML property of element
     * @param {String} value
     * @return {Fluent}
     */
    html: function(value) {
      return this.each(function(element, index) {
        if(element.innerHTML !== undefined) {
          element.innerHTML = value;
        }
      });
    },
    /**
     * set textContent property of element
     * @param {String} value
     * @return {Fluent}
     */
    text: function(value) {
      return this.each(function(element, index) {
        if(element.textContent !== undefined) {
          element.textContent = value;
        }
      });
    },
    /**
     * set value property of element
     * @param {String} value
     * @return {Fluent}
     */
    val: function(value) {
      return this.each(function(element, index) {
        if(element.value !== undefined) {
          element.value = value;
        }
      });
    },
    /**
     * set or add attribute
     * @param {String} key
     * @param {String} value
     * @return {Fluent}
     */
    attr: function(key, value) {
      return this.each(function(element, index) {
        element.setAttribute(key, value);
      });
    },
    /**
     * set or add dataset
     * @param {String} key
     * @param {String} value
     * @return {Fluent}
     */
    data: function(key, value) {
      var datasetAttr = Fluent.camelize(&quot;data-&quot; + key);
      return this.each(function(element, index) {
        element.dataset[datasetAttr] = value;
      });
    },
    /**
     * set style of element
     * @param {String} key
     * @param {String} value
     * @return {Fluent}
     */
    css: function(key, value) {
      return this.each(function(element, index) {
        element.style[key] = value;
      });
    },
    /**
     * add class to element
     * @param {String} className
     * @return {Fluent}
     */
    addClass: function(className) {
      if(!className) {
        return this;
      }
      var list = className.split(&quot; &quot;);
      return this.each(function(element, index) {
        for(var i = 0, len = list.length;i &lt; len;i++) {
          Fluent.addClass(element, list[i]);
        }
      });
    },
    /**
     * remove class from element
     * @param {String} className
     * @return {Fluent}
     */
    removeClass: function(className) {
      if(!className){
        return this;
      }
      var list = className.split(&quot; &quot;);
      return this.each(function(element, index) {
        for(var i = 0, len = list.length;i &lt; len;i++) {
          Fluent.removeClass(element, list[i]);
        }
      });
    },
    /**
     * toggle class of element
     * @param {String} className
     * @return {Fluent}
     */
    toggleClass: function(className) {
      if(!className){
        return this;
      }
      var list = className.split(&quot; &quot;);
      return this.each(function(element, index) {
        for(var i = 0, len = list.length;i &lt; len;i++) {
          Fluent.toggleClass(element, list[i]);
        }
      });
    },
    /**
     * append element
     * @param {HTMLElement}
     * @return {Fluent}
     */
    append: function(value) {
      var nodeList = __normalizeNode(value);
      Fluent.each(this, function(element) {
        for(var i = 0, len = nodeList.length;i &lt; len;i++) {
          if(__isAppendable(nodeList[i])) {
            element.appendChild(nodeList[i]);
          }
        }
      });
      return this;
    },
    /**
     * insert element
     * @param {HTMLElement}
     * @return {Fluent}
     */
    insert: function(value) {
      var nodeList = __normalizeNode(value);
      Fluent.each(this, function(element) {
        for(var i = 0, len = nodeList.length;i &lt; len;i++) {
          element.insertBefore(nodeList[i], element.firstChild);
        }
      });
      return this;
    },
    /**
     * show all element as computed styles
     */
    show: function() {
      for(var i = 0, len = this.length;i &lt; len;i++) {
        this[i].style.display = &quot;&quot;;
        if(__computedStyle(this[i], &quot;display&quot;) === &quot;none&quot;) {
          this[i].style.display = &quot;block&quot;;
        }
      }
    },
    /**
     * hide all element
     */
    hide: function() {
      return this.css(&quot;display&quot;, &quot;none&quot;);
    }
  };

  //extend Fluent prototype
  Fluent.extend(Fluent.fn, _FluentEvent);
  Fluent.extend(Fluent.fn, _FluentTraversing);
  Fluent.extend(Fluent.fn, _FluentManipulation);

  win.$ = win.Fluent = Fluent;

})(window);</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
